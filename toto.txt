Contenu de ./src/Core/Main.cpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** Main.cpp
*/

#include "../include/Core/DisplayInterface.hpp"
#include "../include/Core/GameInterface.hpp"
#include "../include/Core/DLLoader.hpp"

#include <iostream>

int main(int argc, char** argv)
{
    try {
        DLLoader<IDisplay> displayLoader;
        DLLoader<IGame> gameLoader;

        auto display = displayLoader.load(argv[1]);
        auto game = gameLoader.load("./lib/arcade_Pacman.so");

        display->init();

        while(true) {
            int input = display->getInput();
            if(input == -1) break;
            game->handleInput(input);
            GameState state = game->update();
            display->render(state);
        }
        display->close();
    } catch(const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}


Contenu de ./src/Games/Menu/Menu.cpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** Menu.cpp
*/

#include "../../../include/Games/Menu.hpp"


Contenu de ./src/Games/Pacman/Pacman.cpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** Pacman.cpp
*/

#include "../../../include/Games/Pacman.hpp"
#include <fstream>
#include <algorithm>

Pacman::Pacman()
{
    reset();
}

void Pacman::reset()
{
    score = 0;
    lives = 3;
    level = 1;
    highscore = 0;
    is_sous_frozen = false;
    pos_player = DEFAULT_PLAYER_POSITION;
    pos_red_ghost = RED_GHOST_POS;
    pos_pink_ghost = PINK_GHOST_POS;
    pos_blue_ghost = BLUE_GHOST_POS;
    pos_orange_ghost = ORANGE_GHOST_POS;
    loadMap();
}

GameState Pacman::update()
{
    // Déplacement des fantômes
    pos_red_ghost = move_ghost(pos_red_ghost, RED_GHOST);
    pos_pink_ghost = move_ghost(pos_pink_ghost, PINK_GHOST);
    pos_blue_ghost = move_ghost(pos_blue_ghost, BLUE_GHOST);
    pos_orange_ghost = move_ghost(pos_orange_ghost, ORANGE_GHOST);

    if (win_condition()) {
        level++;
        loadMap();
        reset();
    }
    state.map = map;
    state.score = score;
    state.lives = lives;
    state.level = level;
    state.gameName = "Pacman";
    state.playerPos = pos_player;
    state.ghostsPos = {pos_red_ghost, pos_pink_ghost, pos_blue_ghost, pos_orange_ghost};
    return state;
}

void Pacman::handleInput(int key)
{
    int x = pos_player.first;
    int y = pos_player.second;

    switch(key) {
        case 0: // UP
            if (x > 0 && map[x - 1][y] != WALL) movePlayer(x - 1, y);
            break;
        case 1: // DOWN
            if (x < MAP_HEIGHT - 1 && map[x + 1][y] != WALL) movePlayer(x + 1, y);
            break;
        case 2: // LEFT
            if (y > 0 && map[x][y - 1] != WALL) movePlayer(x, y - 1);
            break;
        case 3: // RIGHT
            if (y < (int)map[x].size() - 1 && map[x][y + 1] != WALL) movePlayer(x, y + 1);
            break;
    }
}

void Pacman::movePlayer(int new_x, int new_y)
{
    check_bonuses(map[new_x][new_y]);
    map[pos_player.first][pos_player.second] = EMPTY;
    pos_player = {new_x, new_y};
    map[new_x][new_y] = PLAYER;
}

void Pacman::loadMap() {
    std::ifstream file(DEFAULT_MAP);
    std::string line;
    map.clear();
    original_map.clear();
    coin_map.clear();

    while (std::getline(file, line)) {
        if (line.size() > 0) {
            map.push_back(line);
            original_map.push_back(line);
            coin_map.push_back(line);
        }
    }
}

int Pacman::check_bonuses(char new_pos)
{
    if (new_pos == COIN) {
        this->score += (10 * level);
        return 0;
    } else if (new_pos == POWERUP) {
        this->score += (50 * level);
        this->is_sous_frozen = true;
        return 0;
    }
    if (new_pos == RED_GHOST || new_pos == PINK_GHOST || new_pos == BLUE_GHOST || new_pos == ORANGE_GHOST) {
        this->lives -= 1;
        this->pos_player = DEFAULT_PLAYER_POSITION;
        return 1;
    }
    if (new_pos == TELEPORT) {
        if (this->pos_player == std::make_pair(TELEPORT_1.first, TELEPORT_1.second + 1)) {
            this->pos_player = TELEPORT_2;
            this->pos_player.second -= 2;
        } else {
            this->pos_player = TELEPORT_1;
            this->pos_player.second += 1;
        }
        this->map[pos_player.first][pos_player.second] = PLAYER;
        return 1;
    }
    return 0;
}

bool Pacman::win_condition()
{
    for (int i = 0; i < MAP_HEIGHT; i++) {
        for (int j = 0; j < this->map[i].length(); j++) {
            if (this->map[i][j] == COIN || this->map[i][j] == POWERUP)
                return 0;
        }
    }
    return 1;
}

int Pacman::manhattan_distance(std::pair<int, int> a, std::pair<int, int> b)
{
    return abs(a.first - b.first) + abs(a.second - b.second);
}

std::pair<int, int> Pacman::move_ghost(std::pair<int, int> pos_ghost, char Ghost)
{
    int distance, tmp = manhattan_distance(pos_ghost, this->pos_player);
    std::pair<int, int> new_pos = pos_ghost;

    if (this->map[pos_ghost.first - 1][pos_ghost.second] != WALL && this->map[pos_ghost.first - 1][pos_ghost.second] != BLUE_GHOST && this->map[pos_ghost.first - 1][pos_ghost.second] != ORANGE_GHOST && this->map[pos_ghost.first - 1][pos_ghost.second] != PINK_GHOST && this->map[pos_ghost.first - 1][pos_ghost.second] != RED_GHOST) {
        if (distance >= manhattan_distance(std::make_pair(pos_ghost.first - 1, pos_ghost.second), this->pos_player)) {
            distance = manhattan_distance(std::make_pair(pos_ghost.first - 1, pos_ghost.second), this->pos_player);
            new_pos = std::make_pair(pos_ghost.first - 1, pos_ghost.second);
        }
    }
    if (this->map[pos_ghost.first + 1][pos_ghost.second] != WALL && this->map[pos_ghost.first + 1][pos_ghost.second] != BLUE_GHOST && this->map[pos_ghost.first + 1][pos_ghost.second] != ORANGE_GHOST && this->map[pos_ghost.first + 1][pos_ghost.second] != PINK_GHOST && this->map[pos_ghost.first + 1][pos_ghost.second] != RED_GHOST) {
        if (distance >= manhattan_distance(std::make_pair(pos_ghost.first + 1, pos_ghost.second), this->pos_player)) {
            distance = manhattan_distance(std::make_pair(pos_ghost.first + 1, pos_ghost.second), this->pos_player);
            new_pos = std::make_pair(pos_ghost.first + 1, pos_ghost.second);
        }
    }
    if (this->map[pos_ghost.first][pos_ghost.second - 1] != WALL && this->map[pos_ghost.first][pos_ghost.second - 1] != BLUE_GHOST && this->map[pos_ghost.first][pos_ghost.second - 1] != ORANGE_GHOST && this->map[pos_ghost.first][pos_ghost.second - 1] != PINK_GHOST && this->map[pos_ghost.first][pos_ghost.second - 1] != RED_GHOST) {
        if (distance >= manhattan_distance(std::make_pair(pos_ghost.first, pos_ghost.second - 1), this->pos_player)) {
            distance = manhattan_distance(std::make_pair(pos_ghost.first, pos_ghost.second - 1), this->pos_player);
            new_pos = std::make_pair(pos_ghost.first, pos_ghost.second - 1);
        }
    }
    if (this->map[pos_ghost.first][pos_ghost.second + 1] != WALL && this->map[pos_ghost.first][pos_ghost.second + 1] != BLUE_GHOST && this->map[pos_ghost.first][pos_ghost.second + 1] != ORANGE_GHOST && this->map[pos_ghost.first][pos_ghost.second + 1] != PINK_GHOST && this->map[pos_ghost.first][pos_ghost.second + 1] != RED_GHOST) {
        if (distance >= manhattan_distance(std::make_pair(pos_ghost.first, pos_ghost.second + 1), this->pos_player)) {
            distance = manhattan_distance(std::make_pair(pos_ghost.first, pos_ghost.second + 1), this->pos_player);
            new_pos = std::make_pair(pos_ghost.first, pos_ghost.second + 1);
        }
    }
    if (tmp == distance)
        return new_pos;
    if (this->map[new_pos.first][new_pos.second] == PLAYER) {
        this->lives -= 1;
        this->pos_player = DEFAULT_PLAYER_POSITION;
    }
    if (this->original_map[pos_ghost.first][pos_ghost.second] == BLUE_GHOST || this->original_map[pos_ghost.first][pos_ghost.second] == ORANGE_GHOST || this->original_map[pos_ghost.first][pos_ghost.second] == PINK_GHOST || this->original_map[pos_ghost.first][pos_ghost.second] == RED_GHOST || this->original_map[pos_ghost.first][pos_ghost.second] == PLAYER)
        this->map[pos_ghost.first][pos_ghost.second] = EMPTY;
    else {
        if (this->coin_map[pos_ghost.first][pos_ghost.second] == COIN || this->coin_map[pos_ghost.first][pos_ghost.second] == POWERUP)
            this->map[pos_ghost.first][pos_ghost.second] = this->original_map[pos_ghost.first][pos_ghost.second];
        else
            this->map[pos_ghost.first][pos_ghost.second] = EMPTY;
    }
    this->map[new_pos.first][new_pos.second] = Ghost;
    return new_pos;
}

extern "C" IGame* create()
{
    return new Pacman();
}


Contenu de ./src/Libs/sdl2/sdl2.cpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** SDL2.cpp
*/

#include "../../../include/Core/DisplayInterface.hpp"
#include <SDL2/SDL.h>

class SDL2Display : public IDisplay {
    SDL_Window* window;
    SDL_Renderer* renderer;

public:
    void init() override {
        SDL_Init(SDL_INIT_VIDEO);
        window = SDL_CreateWindow("Arcade", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800, 600, 0);
        renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    }

    void close() override {
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        SDL_Quit();
    }

    void render(const GameState& state) override
    {
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);

        // recup de tileset du jeu lancé

        SDL_RenderPresent(renderer);
    }

    int getInput() override {
        SDL_Event e;
        while(SDL_PollEvent(&e)) {
            if(e.type == SDL_QUIT) return -1;
            if(e.type == SDL_KEYDOWN) {
                switch(e.key.keysym.sym) {
                    case SDLK_UP:    return 0;
                    case SDLK_DOWN:  return 1;
                    case SDLK_LEFT:  return 2;
                    case SDLK_RIGHT: return 3;
                }
            }
        }
        return -2;
    }
    std::string getName() const override { return "SDL2"; }
};

extern "C" IDisplay* create() { return new SDL2Display(); }


Contenu de ./src/Libs/sfml/sfml.cpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** SFML.cpp
*/

#include "../../../include/Core/DisplayInterface.hpp"
#include <SFML/Graphics.hpp>

class SFMLDisplay : public IDisplay
{
    sf::RenderWindow window;
public:
    void init() override {
        window.create(sf::VideoMode(800, 600), "Arcade");
    }

    void close() override {
        window.close();
    }

    void render(const GameState& state) override
    {
        window.clear(sf::Color::Black);

        // recup de tileset du jeu lancé

        window.display();
    }

    int getInput() override {
        sf::Event e;
        while(window.pollEvent(e)) {
            if(e.type == sf::Event::Closed) return -1;
            if(e.type == sf::Event::KeyPressed) {
                switch(e.key.code) {
                    case sf::Keyboard::Up:    return 0;
                    case sf::Keyboard::Down:  return 1;
                    case sf::Keyboard::Left:  return 2;
                    case sf::Keyboard::Right: return 3;
                }
            }
        }
        return -2;
    }
    std::string getName() const override { return "SFML"; }
};

extern "C" IDisplay* create() { return new SFMLDisplay(); }


Contenu de ./src/Libs/ncurses/ncurses.cpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** Ncurses.cpp
*/

#include "../../../include/Core/DisplayInterface.hpp"
#include <ncurses.h>

class NcursesDisplay : public IDisplay
{
    public:
        void init() override {
            initscr();
            noecho();
            curs_set(0);
            keypad(stdscr, TRUE);
        }

        void close() override
        {
            endwin();
        }

        void render(const GameState& state) override {
            clear();
            // recup de tileset du jeu lancé
            refresh();
        }

        int getInput() override {
            switch(getch()) {
                case KEY_UP:    return 0;
                case KEY_DOWN:  return 1;
                case KEY_LEFT:  return 2;
                case KEY_RIGHT: return 3;
                case 'q':       return -1;
            }
            return -2;
        }
        std::string getName() const override { return "Ncurses"; }
};

extern "C" IDisplay* create() { return new NcursesDisplay(); }


Contenu de ./lib/.gitkeep :


Contenu de ./include/Core/DisplayInterface.hpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** DisplayInterface.hpp
*/

#pragma once
#include <string>
#include <iostream>
#include <fstream>
#include <vector>
using namespace std;

struct GameState {
    std::vector<std::string> map;
    int score;
    int lives;
    int level;
    std::string gameName;
    // Ajouts :
    std::pair<int, int> playerPos;
    std::vector<std::pair<int, int>> ghostsPos;
};

class IDisplay {
    public:
        virtual ~IDisplay() = default;
        virtual void init() = 0;
        virtual void close() = 0;
        virtual void render(const GameState& state) = 0;
        virtual int getInput() = 0;
        virtual std::string getName() const = 0;
};


Contenu de ./include/Core/GameInterface.hpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** GameInterface.hpp
*/

#pragma once
#include "DisplayInterface.hpp"

class IGame {
    public:
        virtual ~IGame() = default;
        virtual GameState update() = 0;
        virtual void handleInput(int key) = 0;
        virtual std::string getName() const = 0;
        virtual void reset() = 0;
};


Contenu de ./include/Core/DLLoader.hpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** DLLoader.hpp
*/

#pragma once
#include <dlfcn.h>
#include <string>
#include <stdexcept>

template <typename T>
class DLLoader {
    private:
        void* handle;
        T* instance;
    public:
        DLLoader() : handle(nullptr), instance(nullptr) {}
        T* load(const std::string& path) {
            if (handle) dlclose(handle);
            handle = dlopen(path.c_str(), RTLD_LAZY);
            if (!handle) throw std::runtime_error(dlerror());
            auto create = reinterpret_cast<T*(*)()>(dlsym(handle, "create"));
            if (!create) throw std::runtime_error(dlerror());
            instance = create();
            return instance;
        }
        ~DLLoader() {
            if (handle) {
                delete instance;
                dlclose(handle);
            }
        }
};


Contenu de ./include/Games/Menu.hpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** Menu.hpp
*/



Contenu de ./include/Games/Pacman.hpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** Pacman.hpp
*/

#pragma once
#include "../Core/GameInterface.hpp"
#include <vector>

    #define MAP_HEIGHT 25
    #define PLAYER 'C'
    #define WALL '#'
    #define RED_GHOST 'R'
    #define PINK_GHOST 'P'
    #define BLUE_GHOST 'B'
    #define ORANGE_GHOST 'O'
    #define COIN '.'
    #define EMPTY ' '
    #define POWERUP '@'
    #define TELEPORT 'T'
    #define MAP_HEIGHT 25
    #define DEFAULT_PLAYER_POSITION std::make_pair(18, 11)
    #define RED_GHOST_POS std::make_pair(11, 9)
    #define PINK_GHOST_POS std::make_pair(11, 13)
    #define BLUE_GHOST_POS std::make_pair(11, 12)
    #define ORANGE_GHOST_POS std::make_pair(11, 10)
    #define TELEPORT_1 std::make_pair(11, 1)
    #define TELEPORT_2 std::make_pair(11, 22)
    #define DEFAULT_MAP "Assets/Maps/pacman_map.txt"


class Pacman : public IGame {
protected:
    GameState state;
    int score;
    int lives;
    int level;
    int highscore;
    bool is_sous_frozen;
    std::pair<int, int> pos_player;
    std::pair<int, int> pos_red_ghost;
    std::pair<int, int> pos_pink_ghost;
    std::pair<int, int> pos_blue_ghost;
    std::pair<int, int> pos_orange_ghost;
    std::vector<std::string> map;
    std::vector<std::string> original_map;
    std::vector<std::string> coin_map;

public:
    Pacman();
    GameState update() override;
    void handleInput(int key) override;
    std::string getName() const override { return "Pacman"; }
    void reset() override;

private:
    void loadMap();
    void movePlayer(int new_x, int new_y);
    int check_bonuses(char cell);
    bool win_condition();
    std::pair<int, int> move_ghost(std::pair<int, int> pos, char type);
    int manhattan_distance(std::pair<int, int> a, std::pair<int, int> b);
};


Contenu de ./Makefile :
##
## EPITECH PROJECT, 2024
## My_arc
## File description:
## Makefile
##

CXX	=	g++
CXXFLAGS	=	-std=c++17 -fPIC
LDFLAGS	=	-ldl
LIBS	=	-lSDL2

SRC_DIR	=	src
INC_DIR	=	include
LIB_DIR	=	lib

GAMES	=	Pacman	\
			Menu

LIBS_GRAPHIC	=	ncurses	\
					sdl2	\
					sfml

all: core games graphicals

core:
	$(CXX) $(CXXFLAGS) -I$(INC_DIR) -c $(SRC_DIR)/Core/Main.cpp -o Main.o
	$(CXX) $(CXXFLAGS) -I$(INC_DIR) -c $(SRC_DIR)/Core/DLLoader.cpp -o DLLoader.o
	$(CXX) Main.o DLLoader.o -o arcade $(LDFLAGS)

games:
	@for game in $(GAMES); do \
		$(CXX) $(CXXFLAGS) -I$(INC_DIR) -shared $(SRC_DIR)/Games/$$game/$$game.cpp -o $(LIB_DIR)/arcade_$$game.so; \
	done

clean:
	rm -f *.o arcade $(LIB_DIR)/*.so

fclean: clean
	rm -f $(LIB_DIR)/*.so
	rm -f *.so

re: fclean all


Contenu de ./toto.txt :
Contenu de ./.github/workflows/unitest.yml :
name: Unitest C++

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Clone repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt update && sudo apt install -y \
            g++ \
            libncurses-dev \
            libsdl2-dev \
            libsdl2-ttf-dev \
            libsfml-dev \
            cmake \
            make

      - name: Build & Test
        run: |
          make unitest


Contenu de ./src/Core/DLLoader.cpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** DLLoader.cpp
*/



Contenu de ./src/Core/Main.cpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** Main.cpp
*/

#include "../include/Core/DisplayInterface.hpp"
#include "../include/Core/GameInterface.hpp"
#include "../include/Core/DLLoader.hpp"

#include <iostream>

int main(int argc, char** argv)
{
    try {
        DLLoader<IDisplay> displayLoader;
        DLLoader<IGame> gameLoader;

        auto display = displayLoader.load(argv[1]);
        auto game = gameLoader.load("./lib/arcade_Pacman.so");

        display->init();

        while(true) {
            int input = display->getInput();
            if(input == -1) break;
            game->handleInput(input);
            GameState state = game->update();
            display->render(state);
        }
        display->close();
    } catch(const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}


Contenu de ./src/Games/Menu/Menu.cpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** Menu.cpp
*/

#include "../../../include/Games/Menu.hpp"


Contenu de ./src/Games/Pacman/Pacman.cpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** Pacman.cpp
*/

#include "../../../include/Games/Pacman.hpp"
#include <fstream>
#include <algorithm>

Pacman::Pacman()
{
    reset();
}

void Pacman::reset()
{
    score = 0;
    lives = 3;
    level = 1;
    highscore = 0;
    is_sous_frozen = false;
    pos_player = DEFAULT_PLAYER_POSITION;
    pos_red_ghost = RED_GHOST_POS;
    pos_pink_ghost = PINK_GHOST_POS;
    pos_blue_ghost = BLUE_GHOST_POS;
    pos_orange_ghost = ORANGE_GHOST_POS;
    loadMap();
}

GameState Pacman::update()
{
    // Déplacement des fantômes
    pos_red_ghost = move_ghost(pos_red_ghost, RED_GHOST);
    pos_pink_ghost = move_ghost(pos_pink_ghost, PINK_GHOST);
    pos_blue_ghost = move_ghost(pos_blue_ghost, BLUE_GHOST);
    pos_orange_ghost = move_ghost(pos_orange_ghost, ORANGE_GHOST);

    if (win_condition()) {
        level++;
        loadMap();
        reset();
    }
    state.map = map;
    state.score = score;
    state.lives = lives;
    state.level = level;
    state.gameName = "Pacman";
    state.playerPos = pos_player;
    state.ghostsPos = {pos_red_ghost, pos_pink_ghost, pos_blue_ghost, pos_orange_ghost};
    return state;
}

void Pacman::handleInput(int key)
{
    int x = pos_player.first;
    int y = pos_player.second;

    switch(key) {
        case 0: // UP
            if (x > 0 && map[x - 1][y] != WALL) movePlayer(x - 1, y);
            break;
        case 1: // DOWN
            if (x < MAP_HEIGHT - 1 && map[x + 1][y] != WALL) movePlayer(x + 1, y);
            break;
        case 2: // LEFT
            if (y > 0 && map[x][y - 1] != WALL) movePlayer(x, y - 1);
            break;
        case 3: // RIGHT
            if (y < (int)map[x].size() - 1 && map[x][y + 1] != WALL) movePlayer(x, y + 1);
            break;
    }
}

void Pacman::movePlayer(int new_x, int new_y)
{
    check_bonuses(map[new_x][new_y]);
    map[pos_player.first][pos_player.second] = EMPTY;
    pos_player = {new_x, new_y};
    map[new_x][new_y] = PLAYER;
}

void Pacman::loadMap() {
    std::ifstream file(DEFAULT_MAP);
    std::string line;
    map.clear();
    original_map.clear();
    coin_map.clear();

    while (std::getline(file, line)) {
        if (line.size() > 0) {
            map.push_back(line);
            original_map.push_back(line);
            coin_map.push_back(line);
        }
    }
}

int Pacman::check_bonuses(char new_pos)
{
    if (new_pos == COIN) {
        this->score += (10 * level);
        return 0;
    } else if (new_pos == POWERUP) {
        this->score += (50 * level);
        this->is_sous_frozen = true;
        return 0;
    }
    if (new_pos == RED_GHOST || new_pos == PINK_GHOST || new_pos == BLUE_GHOST || new_pos == ORANGE_GHOST) {
        this->lives -= 1;
        this->pos_player = DEFAULT_PLAYER_POSITION;
        return 1;
    }
    if (new_pos == TELEPORT) {
        if (this->pos_player == std::make_pair(TELEPORT_1.first, TELEPORT_1.second + 1)) {
            this->pos_player = TELEPORT_2;
            this->pos_player.second -= 2;
        } else {
            this->pos_player = TELEPORT_1;
            this->pos_player.second += 1;
        }
        this->map[pos_player.first][pos_player.second] = PLAYER;
        return 1;
    }
    return 0;
}

bool Pacman::win_condition()
{
    for (int i = 0; i < MAP_HEIGHT; i++) {
        for (int j = 0; j < this->map[i].length(); j++) {
            if (this->map[i][j] == COIN || this->map[i][j] == POWERUP)
                return 0;
        }
    }
    return 1;
}

int Pacman::manhattan_distance(std::pair<int, int> a, std::pair<int, int> b)
{
    return abs(a.first - b.first) + abs(a.second - b.second);
}

std::pair<int, int> Pacman::move_ghost(std::pair<int, int> pos_ghost, char Ghost)
{
    int distance, tmp = manhattan_distance(pos_ghost, this->pos_player);
    std::pair<int, int> new_pos = pos_ghost;

    if (this->map[pos_ghost.first - 1][pos_ghost.second] != WALL && this->map[pos_ghost.first - 1][pos_ghost.second] != BLUE_GHOST && this->map[pos_ghost.first - 1][pos_ghost.second] != ORANGE_GHOST && this->map[pos_ghost.first - 1][pos_ghost.second] != PINK_GHOST && this->map[pos_ghost.first - 1][pos_ghost.second] != RED_GHOST) {
        if (distance >= manhattan_distance(std::make_pair(pos_ghost.first - 1, pos_ghost.second), this->pos_player)) {
            distance = manhattan_distance(std::make_pair(pos_ghost.first - 1, pos_ghost.second), this->pos_player);
            new_pos = std::make_pair(pos_ghost.first - 1, pos_ghost.second);
        }
    }
    if (this->map[pos_ghost.first + 1][pos_ghost.second] != WALL && this->map[pos_ghost.first + 1][pos_ghost.second] != BLUE_GHOST && this->map[pos_ghost.first + 1][pos_ghost.second] != ORANGE_GHOST && this->map[pos_ghost.first + 1][pos_ghost.second] != PINK_GHOST && this->map[pos_ghost.first + 1][pos_ghost.second] != RED_GHOST) {
        if (distance >= manhattan_distance(std::make_pair(pos_ghost.first + 1, pos_ghost.second), this->pos_player)) {
            distance = manhattan_distance(std::make_pair(pos_ghost.first + 1, pos_ghost.second), this->pos_player);
            new_pos = std::make_pair(pos_ghost.first + 1, pos_ghost.second);
        }
    }
    if (this->map[pos_ghost.first][pos_ghost.second - 1] != WALL && this->map[pos_ghost.first][pos_ghost.second - 1] != BLUE_GHOST && this->map[pos_ghost.first][pos_ghost.second - 1] != ORANGE_GHOST && this->map[pos_ghost.first][pos_ghost.second - 1] != PINK_GHOST && this->map[pos_ghost.first][pos_ghost.second - 1] != RED_GHOST) {
        if (distance >= manhattan_distance(std::make_pair(pos_ghost.first, pos_ghost.second - 1), this->pos_player)) {
            distance = manhattan_distance(std::make_pair(pos_ghost.first, pos_ghost.second - 1), this->pos_player);
            new_pos = std::make_pair(pos_ghost.first, pos_ghost.second - 1);
        }
    }
    if (this->map[pos_ghost.first][pos_ghost.second + 1] != WALL && this->map[pos_ghost.first][pos_ghost.second + 1] != BLUE_GHOST && this->map[pos_ghost.first][pos_ghost.second + 1] != ORANGE_GHOST && this->map[pos_ghost.first][pos_ghost.second + 1] != PINK_GHOST && this->map[pos_ghost.first][pos_ghost.second + 1] != RED_GHOST) {
        if (distance >= manhattan_distance(std::make_pair(pos_ghost.first, pos_ghost.second + 1), this->pos_player)) {
            distance = manhattan_distance(std::make_pair(pos_ghost.first, pos_ghost.second + 1), this->pos_player);
            new_pos = std::make_pair(pos_ghost.first, pos_ghost.second + 1);
        }
    }
    if (tmp == distance)
        return new_pos;
    if (this->map[new_pos.first][new_pos.second] == PLAYER) {
        this->lives -= 1;
        this->pos_player = DEFAULT_PLAYER_POSITION;
    }
    if (this->original_map[pos_ghost.first][pos_ghost.second] == BLUE_GHOST || this->original_map[pos_ghost.first][pos_ghost.second] == ORANGE_GHOST || this->original_map[pos_ghost.first][pos_ghost.second] == PINK_GHOST || this->original_map[pos_ghost.first][pos_ghost.second] == RED_GHOST || this->original_map[pos_ghost.first][pos_ghost.second] == PLAYER)
        this->map[pos_ghost.first][pos_ghost.second] = EMPTY;
    else {
        if (this->coin_map[pos_ghost.first][pos_ghost.second] == COIN || this->coin_map[pos_ghost.first][pos_ghost.second] == POWERUP)
            this->map[pos_ghost.first][pos_ghost.second] = this->original_map[pos_ghost.first][pos_ghost.second];
        else
            this->map[pos_ghost.first][pos_ghost.second] = EMPTY;
    }
    this->map[new_pos.first][new_pos.second] = Ghost;
    return new_pos;
}

extern "C" IGame* create()
{
    return new Pacman();
}


Contenu de ./src/Libs/sdl2/sdl2.cpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** SDL2.cpp
*/

#include "../../../include/Core/DisplayInterface.hpp"
#include <SDL2/SDL.h>

class SDL2Display : public IDisplay {
    SDL_Window* window;
    SDL_Renderer* renderer;

public:
    void init() override {
        SDL_Init(SDL_INIT_VIDEO);
        window = SDL_CreateWindow("Arcade", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800, 600, 0);
        renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    }

    void close() override {
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        SDL_Quit();
    }

    void render(const GameState& state) override
    {
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);

        // recup de tileset du jeu lancé

        SDL_RenderPresent(renderer);
    }

    int getInput() override {
        SDL_Event e;
        while(SDL_PollEvent(&e)) {
            if(e.type == SDL_QUIT) return -1;
            if(e.type == SDL_KEYDOWN) {
                switch(e.key.keysym.sym) {
                    case SDLK_UP:    return 0;
                    case SDLK_DOWN:  return 1;
                    case SDLK_LEFT:  return 2;
                    case SDLK_RIGHT: return 3;
                }
            }
        }
        return -2;
    }
    std::string getName() const override { return "SDL2"; }
};

extern "C" IDisplay* create() { return new SDL2Display(); }


Contenu de ./src/Libs/sfml/sfml.cpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** SFML.cpp
*/

#include "../../../include/Core/DisplayInterface.hpp"
#include <SFML/Graphics.hpp>

class SFMLDisplay : public IDisplay
{
    sf::RenderWindow window;
public:
    void init() override {
        window.create(sf::VideoMode(800, 600), "Arcade");
    }

    void close() override {
        window.close();
    }

    void render(const GameState& state) override
    {
        window.clear(sf::Color::Black);

        // recup de tileset du jeu lancé

        window.display();
    }

    int getInput() override {
        sf::Event e;
        while(window.pollEvent(e)) {
            if(e.type == sf::Event::Closed) return -1;
            if(e.type == sf::Event::KeyPressed) {
                switch(e.key.code) {
                    case sf::Keyboard::Up:    return 0;
                    case sf::Keyboard::Down:  return 1;
                    case sf::Keyboard::Left:  return 2;
                    case sf::Keyboard::Right: return 3;
                }
            }
        }
        return -2;
    }
    std::string getName() const override { return "SFML"; }
};

extern "C" IDisplay* create() { return new SFMLDisplay(); }


Contenu de ./src/Libs/ncurses/ncurses.cpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** Ncurses.cpp
*/

#include "../../../include/Core/DisplayInterface.hpp"
#include <ncurses.h>

class NcursesDisplay : public IDisplay
{
    public:
        void init() override {
            initscr();
            noecho();
            curs_set(0);
            keypad(stdscr, TRUE);
        }

        void close() override
        {
            endwin();
        }

        void render(const GameState& state) override {
            clear();
            // recup de tileset du jeu lancé
            refresh();
        }

        int getInput() override {
            switch(getch()) {
                case KEY_UP:    return 0;
                case KEY_DOWN:  return 1;
                case KEY_LEFT:  return 2;
                case KEY_RIGHT: return 3;
                case 'q':       return -1;
            }
            return -2;
        }
        std::string getName() const override { return "Ncurses"; }
};

extern "C" IDisplay* create() { return new NcursesDisplay(); }


Contenu de ./lib/.gitkeep :


Contenu de ./include/Core/DisplayInterface.hpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** DisplayInterface.hpp
*/

#pragma once
#include <string>
#include <iostream>
#include <fstream>
#include <vector>
using namespace std;

struct GameState {
    std::vector<std::string> map;
    int score;
    int lives;
    int level;
    std::string gameName;
    // Ajouts :
    std::pair<int, int> playerPos;
    std::vector<std::pair<int, int>> ghostsPos;
};

class IDisplay {
    public:
        virtual ~IDisplay() = default;
        virtual void init() = 0;
        virtual void close() = 0;
        virtual void render(const GameState& state) = 0;
        virtual int getInput() = 0;
        virtual std::string getName() const = 0;
};


Contenu de ./include/Core/GameInterface.hpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** GameInterface.hpp
*/

#pragma once
#include "DisplayInterface.hpp"

class IGame {
    public:
        virtual ~IGame() = default;
        virtual GameState update() = 0;
        virtual void handleInput(int key) = 0;
        virtual std::string getName() const = 0;
        virtual void reset() = 0;
};


Contenu de ./include/Core/DLLoader.hpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** DLLoader.hpp
*/

#pragma once
#include <dlfcn.h>
#include <string>
#include <stdexcept>

template <typename T>
class DLLoader {
    private:
        void* handle;
        T* instance;
    public:
        DLLoader() : handle(nullptr), instance(nullptr) {}
        T* load(const std::string& path) {
            if (handle) dlclose(handle);
            handle = dlopen(path.c_str(), RTLD_LAZY);
            if (!handle) throw std::runtime_error(dlerror());
            auto create = reinterpret_cast<T*(*)()>(dlsym(handle, "create"));
            if (!create) throw std::runtime_error(dlerror());
            instance = create();
            return instance;
        }
        ~DLLoader() {
            if (handle) {
                delete instance;
                dlclose(handle);
            }
        }
};


Contenu de ./include/Games/Menu.hpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** Menu.hpp
*/



Contenu de ./include/Games/Pacman.hpp :
/*
** EPITECH PROJECT, 2024
** B-OOP-400-MAR-4-1-arcade-yanis.prevost
** File description:
** Pacman.hpp
*/

#pragma once
#include "../Core/GameInterface.hpp"
#include <vector>

    #define MAP_HEIGHT 25
    #define PLAYER 'C'
    #define WALL '#'
    #define RED_GHOST 'R'
    #define PINK_GHOST 'P'
    #define BLUE_GHOST 'B'
    #define ORANGE_GHOST 'O'
    #define COIN '.'
    #define EMPTY ' '
    #define POWERUP '@'
    #define TELEPORT 'T'
    #define MAP_HEIGHT 25
    #define DEFAULT_PLAYER_POSITION std::make_pair(18, 11)
    #define RED_GHOST_POS std::make_pair(11, 9)
    #define PINK_GHOST_POS std::make_pair(11, 13)
    #define BLUE_GHOST_POS std::make_pair(11, 12)
    #define ORANGE_GHOST_POS std::make_pair(11, 10)
    #define TELEPORT_1 std::make_pair(11, 1)
    #define TELEPORT_2 std::make_pair(11, 22)
    #define DEFAULT_MAP "Assets/Maps/pacman_map.txt"


class Pacman : public IGame {
protected:
    GameState state;
    int score;
    int lives;
    int level;
    int highscore;
    bool is_sous_frozen;
    std::pair<int, int> pos_player;
    std::pair<int, int> pos_red_ghost;
    std::pair<int, int> pos_pink_ghost;
    std::pair<int, int> pos_blue_ghost;
    std::pair<int, int> pos_orange_ghost;
    std::vector<std::string> map;
    std::vector<std::string> original_map;
    std::vector<std::string> coin_map;

public:
    Pacman();
    GameState update() override;
    void handleInput(int key) override;
    std::string getName() const override { return "Pacman"; }
    void reset() override;

private:
    void loadMap();
    void movePlayer(int new_x, int new_y);
    int check_bonuses(char cell);
    bool win_condition();
    std::pair<int, int> move_ghost(std::pair<int, int> pos, char type);
    int manhattan_distance(std::pair<int, int> a, std::pair<int, int> b);
};


Contenu de ./Makefile :


